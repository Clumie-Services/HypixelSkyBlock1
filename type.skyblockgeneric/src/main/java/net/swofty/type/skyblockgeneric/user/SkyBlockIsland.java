package net.swofty.type.skyblockgeneric.user;

import lombok.Getter;
import lombok.Setter;
import net.hollowcube.polar.*;
import net.kyori.adventure.key.Key;
import net.minestom.server.MinecraftServer;
import net.minestom.server.instance.InstanceContainer;
import net.minestom.server.instance.InstanceManager;
import net.minestom.server.instance.SharedInstance;
import net.minestom.server.registry.RegistryKey;
import net.minestom.server.timer.ExecutionType;
import net.minestom.server.timer.Scheduler;
import net.minestom.server.timer.TaskSchedule;
import net.minestom.server.world.DimensionType;
import net.swofty.commons.CustomWorlds;
import net.swofty.type.generic.HypixelConst;
import net.swofty.type.generic.user.HypixelPlayer;
import net.swofty.type.skyblockgeneric.SkyBlockGenericLoader;
import net.swofty.type.skyblockgeneric.data.monogdb.CoopDatabase;
import net.swofty.type.skyblockgeneric.data.monogdb.IslandDatabase;
import net.swofty.type.generic.event.HypixelEventHandler;
import net.swofty.type.skyblockgeneric.event.custom.IslandFetchedFromDatabaseEvent;
import net.swofty.type.skyblockgeneric.event.custom.IslandFirstCreatedEvent;
import net.swofty.type.skyblockgeneric.event.custom.IslandSavedIntoDatabaseEvent;
import net.swofty.type.skyblockgeneric.minion.IslandMinionData;
import net.swofty.type.skyblockgeneric.utility.JerryInformation;
import net.swofty.type.generic.utility.MathUtility;
import org.bson.types.Binary;
import org.jetbrains.annotations.Nullable;
import org.tinylog.Logger;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

@Getter
public class SkyBlockIsland {
    private static final String ISLAND_TEMPLATE_NAME = CustomWorlds.SKYBLOCK_ISLAND_TEMPLATE.getFolderName();
    private static final Map<UUID, SkyBlockIsland> loadedIslands = new HashMap<>();

    // Internal Island Data
    private final IslandDatabase database;
    private final CoopDatabase.Coop coop;
    private final UUID islandID;
    private Boolean created = false;
    private SharedInstance islandInstance;
    private PolarWorld world;

    // External Island Data
    @Setter
    private JerryInformation jerryInformation = null;
    @Setter
    private IslandMinionData minionData = null;
    @Setter
    private long lastSaved = 0;
    @Setter
    private Integer islandVersion;

    public SkyBlockIsland(UUID islandID, UUID profileID) {
        this.islandID = islandID;
        this.database = new IslandDatabase(islandID.toString());
        this.coop = CoopDatabase.getFromMemberProfile(profileID);

        loadedIslands.put(islandID, this);
    }

    public CompletableFuture<SharedInstance> getSharedInstance() {
        InstanceManager manager = MinecraftServer.getInstanceManager();
        CompletableFuture<SharedInstance> future = new CompletableFuture<>();

        new Thread(() -> {
            if (created) {
                future.complete(islandInstance);
                return;
            }
            RegistryKey<DimensionType> dimensionTypeKey = MinecraftServer.getDimensionTypeRegistry().getKey(
                    Key.key("skyblock:island")
            );
            InstanceContainer temporaryInstance = manager.createInstanceContainer(dimensionTypeKey);
            islandInstance = manager.createSharedInstance(temporaryInstance);

            List<SkyBlockPlayer> onlinePlayers;
            if (coop != null) {
                onlinePlayers = coop.getOnlineMembers();
            } else {
                // Island ID will be the same as the profile ID if the island is not a coop
                SkyBlockPlayer player = SkyBlockGenericLoader.getPlayerFromProfileUUID(islandID);
                if (player != null) {
                    onlinePlayers = List.of(player);
                } else {
                    // Player's profile data may not be loaded yet, try to find by island reference
                    onlinePlayers = SkyBlockGenericLoader.getLoadedPlayers().stream()
                            .filter(p -> p.getSkyBlockIsland() != null && p.getSkyBlockIsland().getIslandID().equals(islandID))
                            .map(p -> (SkyBlockPlayer) p)
                            .toList();
                }
            }

            if (!database.exists()) {
                islandVersion = HypixelConst.getCurrentIslandVersion();
                try {
                    world = AnvilPolar.anvilToPolar(Path.of(ISLAND_TEMPLATE_NAME), ChunkSelector.radius(3));
                } catch (IOException e) {
                    Logger.error("Failed to create island world", e);
                    throw new RuntimeException("Failed to create island world", e);
                }

                HypixelEventHandler.callCustomEvent(new IslandFirstCreatedEvent(
                        this, coop != null, coop != null ? coop.memberProfiles() : List.of(islandID)
                ));
            } else {
                if (database.has("version"))
                    islandVersion = (int) database.get("version", Integer.class);
                else islandVersion = 0;

                switch (islandVersion) {
                    case 0:
                        lastSaved = System.currentTimeMillis();
                        try {
                            world = AnvilPolar.anvilToPolar(Path.of(ISLAND_TEMPLATE_NAME), ChunkSelector.radius(3));
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                        break;
                    case 1:
                        world = PolarReader.read(((Binary) database.get("data", Binary.class)).getData());
                        lastSaved = (long) database.get("lastSaved", Long.class);
                        break;
                }

                int oldVersion = islandVersion;
                if (islandVersion < HypixelConst.getCurrentIslandVersion()) {
                    MathUtility.delay(() -> {
                        SkyBlockGenericLoader.getLoadedPlayers().stream().filter(player -> player.getSkyBlockIsland().getIslandID() == islandID).forEach(player -> {
                            player.getLogHandler().debug("Your island was migrated from version §c" + oldVersion + " §fto §a" + HypixelConst.getCurrentIslandVersion() + "§f!");
                        });
                    }, 20);
                    islandVersion = HypixelConst.getCurrentIslandVersion();
                }
            }
            temporaryInstance.setChunkLoader(new PolarLoader(world));

            this.created = true;

            HypixelEventHandler.callCustomEvent(new IslandFetchedFromDatabaseEvent(
                    this, coop != null, onlinePlayers, coop != null ? coop.memberProfiles() : List.of(islandID))
            );

            future.complete(islandInstance);
            onlinePlayers.forEach(HypixelPlayer::setReadyForEvents);
        }).start();

        return future;
    }

    public void runVacantCheck() {
        if (islandInstance == null) return;

        if (islandInstance.getPlayers().isEmpty()) {
            HypixelEventHandler.callCustomEvent(new IslandSavedIntoDatabaseEvent(
                    this, coop != null, coop != null ? coop.memberProfiles() : List.of(islandID)
            ));

            save();
            this.created = false;
            islandInstance.getChunks().forEach(chunk -> {
                islandInstance.unloadChunk(chunk);
            });
            this.islandInstance = null;
            this.world = null;
        }
    }

    /**
     * Saves the island world data to the database.
     * This includes the world binary data, last saved timestamp, and version.
     * Can be called manually to force a save (e.g., on player disconnect).
     */
    public void save() {
        if (world == null || islandInstance == null) {
            Logger.warn("Attempted to save island {} but world or instance is null", islandID);
            return;
        }

        try {
            // Save chunks to the PolarWorld
            new PolarLoader(world).saveInstance(islandInstance);

            // Serialize and store in database
            byte[] worldData = PolarWriter.write(world);
            database.insertOrUpdate("data", new Binary(worldData));
            database.insertOrUpdate("lastSaved", System.currentTimeMillis());
            database.insertOrUpdate("version", islandVersion);

            Logger.debug("Successfully saved island {} ({} bytes)", islandID, worldData.length);
        } catch (Exception e) {
            Logger.error("Failed to save island {}: {}", islandID, e.getMessage(), e);
        }
    }

    /**
     * Saves the island if it has been created and has a valid world.
     * This is a safe method to call that won't throw exceptions.
     *
     * @return true if the save was attempted, false if the island wasn't ready
     */
    public boolean saveIfCreated() {
        if (!created || world == null || islandInstance == null) {
            return false;
        }
        save();
        return true;
    }

    public static boolean hasIsland(UUID islandID) {
        return loadedIslands.containsKey(islandID);
    }

    public static @Nullable SkyBlockIsland getIsland(UUID islandID) {
        if (!loadedIslands.containsKey(islandID)) return null;
        return loadedIslands.get(islandID);
    }

    public static void runVacantLoop(Scheduler scheduler) {
        scheduler.submitTask(() -> {
            SkyBlockGenericLoader.getLoadedPlayers().forEach(player -> {
                if (player.isOnIsland())
                    player.getSkyBlockIsland().runVacantCheck();
            });
            return TaskSchedule.tick(4);
        }, ExecutionType.TICK_END);
    }
}